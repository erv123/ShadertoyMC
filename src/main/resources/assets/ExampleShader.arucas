import PerlinNoise, VoronoiNoise from util.Noise;
import Vector3 from util.Vector;
import BlockPalette from BlockPalette;

// Set noise parameters
perlin = new PerlinNoise(10, 1, 10, 2);
fun map(n: Number, aMax, aMin, bMin, bMax) {
    return bMin + (n - aMin) * (bMax - bMin) / (aMax - aMin);
}
// Area iteration where the area is defined by origin and size
// The first three parameters are the origin coordinates and the next three parameters are size in each axis
// Each position gets passed into the 7th parameter lambda as up to three vectors
// The first vector will be the absolute coordinates in the world
// The second vector will be the normalized coordinates that go from -1 -1 -1 to 1 1 1 no matter the area size
// The third will be local area coordinates that are 0 0 0 at area origin
area(32, 100, 100, 200, 1, 200, fun(aPos, nPos, lPos) {
    // Do whatever for this position
    value = perlin.getValue(aPos / Vector3.fromScalar(20));
    index = Math.clamp(map(Math.abs(value), 0, 1, 0, 15).floor(), 0, 15);
    //index = Math.mod(Math.round(Math.abs(value) * 100), 15);
    place(BlockPalette.GRAYSCALE[index], aPos);
    //place("air", aPos.getX(), aPos.getY(), aPos.getZ());
});